{"mappings":"AASA,MAAAA,EAAS,ICFL,MACAC,cAEAC,KAAKC,YAAc,GAErBD,KAAAE,WAAA,EAGEC,QAAAC,KAAMC,GAIN,MAAAC,EAAAN,KAAAC,YAAAG,GACA,IAAIE,EAAU,OAAcC,QAA5BC,KAAA,GAAAJ,eAEE,QAAAK,KAAAH,EAGAA,EAAaG,MACXJ,GAGL,MAAAI,EAAA,WAAAH,EAAAG,GAICC,UAAIN,EAAKO,GAITX,KAAQC,YAAQG,KAEhBJ,KAAAC,YAAAG,GAAA,IACA,MAAAK,EAAAT,KAAAE,aAIAF,KAAAC,YAAiBG,GAAjBK,GAAAE,EAWoB,OACrBC,YAVe,YAGTZ,KAAOC,YAAUG,GAAYK,GAKlC,IAAAI,OAAAC,KAAAd,KAAAC,YAAAG,IAAAW,eAAAf,KAAAC,YAAAG,KAOAY,cAASZ,EAAWO,GAIpBX,KAAQC,YAAcG,KAEtBJ,KAAAC,YAAAG,GAAA,IACA,MAAAK,EAAA,IAAAT,KAAAE,aAIAF,KAAAC,YAAiBG,GAAjBK,GAAAE,EAWoB,OACrBC,YAVe,YAGTZ,KAAOC,YAAUG,GAAYK,GAKlC,IAAAI,OAAAC,KAAAd,KAAAC,YAAAG,IAAAW,eAAAf,KAAAC,YAAAG,KAOAa,MAAAb,GAIEA,SAGLJ,KAAAC,YAAAG,GAHiBJ,KAAAC,YAAuB,K,EDlFtCS,UAAA,WAAAQ,EAAAC,KACHZ,QAAAa,IAAA,WAAAF,EAASC,M,EAENT,UAAA,WAAAQ,EAAAC,KACHZ,QAAAa,IAAA,WAAAF,EAASC,M,EAENT,UAAA,WAAAQ,EAAAC,KAEHZ,QAAAa,IAAA,WAAuBF,EAAAC,M,EACkChB,QAAA,UAEzDkB,IAAQ,oBACR,GAGAvB,EAA+BmB,MAAA,U,EACgCd,QAAA,U","sources":["src/app.js","node_modules/eventbus/dist/src/EventBus.js"],"sourcesContent":["/**\r\n * Created by Rick on 2022-06-04.\r\n */\r\n'use strict';\r\nimport EventBus from 'eventbus';\r\n\r\nconst eventBus = new EventBus();\r\n\r\n// Subscribe to eventX\r\neventBus.subscribe('eventX', (obj,num) => {\r\n  console.log(\"Module A\", obj, num);\r\n});\r\neventBus.subscribe('eventX', (obj,num) => {\r\n  console.log(\"Module B\", obj, num);\r\n});\r\neventBus.subscribe('eventX', (obj,num) => {\r\n  console.log(\"Module C\", obj, num);\r\n});\r\n\r\n// publish event eventX\r\neventBus.publish('eventX', {msg: 'EventX published'}, 1);\r\n\r\n// clear\r\neventBus.clear('eventX');\r\n\r\n// Publish the event eventX again, since it has been cleared, all modules will no\r\n//   longer receive the message\r\neventBus.publish('eventX', {msg: 'EventX published again'}, 2);","/**\r\n * Created by Rick on 2022-05-26.\r\n */\r\n'use strict';\r\n\r\nexport default class EventBus {\r\n  constructor() {\r\n    // initialize event list\r\n    this.eventObject = {};\r\n    // id of the callback function list\r\n    this.callbackId = 0;\r\n  }\r\n  // publish event\r\n  publish(eventName, ...args){\r\n    // Get all the callback functions of the current event\r\n    const callbackObject = this.eventObject[eventName];\r\n\r\n    if(!callbackObject) return console.warn(`${eventName} not found`);\r\n\r\n    // execute each callback function\r\n    for(let id in callbackObject){\r\n      // pass parameters when executiong\r\n      callbackObject[id](...args);\r\n\r\n      // The callback function that is only subscribed once needs to be deleted\r\n      if(id[0] === 'd'){\r\n        delete callbackObject[id];\r\n      }\r\n    }\r\n  }\r\n  // Subscribe to events\r\n  subscribe(eventName, callback){\r\n    // initialize this event\r\n    if(!this.eventObject[eventName]){\r\n      // Use object storage to improve the efficiency of deletion when logging out the callback\r\n      this.eventObject[eventName] = {};\r\n    }\r\n    const id = this.callbackId++;\r\n\r\n    // store the callback function of the subscriber\r\n    // callbackId needs to be incremented after use for the next callback function\r\n    this.eventObject[eventName][id] = callback;\r\n\r\n    // Every time you subscribe to an event, a unique unsubscribe function is generated\r\n    const unSubscribe = () => {\r\n      //clear the callback function of this subscriber\r\n      delete this.eventObject[eventName][id];\r\n\r\n      // If this event has no subscribers, also clear the entire event object\r\n      if(Object.keys(this.eventObject[eventName]).length === 0){\r\n        delete this.eventObject[eventName];\r\n      }\r\n    };\r\n\r\n    // return the unsubscribe function to subscriber\r\n    return {unSubscribe};\r\n  }\r\n\r\n  // Only subscribe once\r\n  subscribeOnce(eventName, callback){\r\n    // initialize this event\r\n    if(!this.eventObject[eventName]){\r\n      // Use object storage to improve the efficiency of deletion when logging out the callback\r\n      this.eventObject[eventName] = {};\r\n    }\r\n    const id = 'd' + this.callbackId++;\r\n\r\n    // store the callback function of the subscriber\r\n    // callbackId needs to be incremented after use for the next callback function\r\n    this.eventObject[eventName][id] = callback;\r\n\r\n    // Every time you subscribe to an event, a unique unsubscribe function is generated\r\n    const unSubscribe = () => {\r\n      //clear the callback function of this subscriber\r\n      delete this.eventObject[eventName][id];\r\n\r\n      // If this event has no subscribers, also clear the entire event object\r\n      if(Object.keys(this.eventObject[eventName]).length === 0){\r\n        delete this.eventObject[eventName];\r\n      }\r\n    };\r\n\r\n    // return the unsubscribe function to subscriber\r\n    return {unSubscribe};\r\n  }\r\n\r\n  // clear event\r\n  clear(eventName){\r\n    // If no event name is provided, all events are cleared by default\r\n    if(!eventName){\r\n      this.eventObject = {};\r\n    }else {\r\n      // clear the specified event\r\n      delete this.eventObject[eventName];\r\n    }\r\n  }\r\n}\r\n\r\n"],"names":["$e73bf42412feb220$var$eventBus","constructor","this","eventObject","callbackId","publish","eventName","args","callbackObject","console","warn","id","subscribe","callback","unSubscribe","Object","keys","length","subscribeOnce","clear","obj","num","log","msg"],"version":3,"file":"index.22d90c8b.js.map"}